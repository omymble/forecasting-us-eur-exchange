# Importing the Necessary Libraries
```{r}

library(readxl)
library(lmtest) 
library(forecast)
library(DIMORA)
library(fpp2)
library(ggplot2)
library(plotly)
library(dplyr)
library(Hmisc)
library(gam)

```

# Importing the Data Sets
```{r}

folder_path = "~/Desktop/unipd/time-series/project/forecasting-us-eur-exchange/data/"

shares_file <- paste0(folder_path, "us-total-share-prices.csv")
m2_file <- paste0(folder_path, "us-M2.csv")
m2_file2 <- paste0(folder_path, "eu-M2.csv")
# usir_file <- paste0(folder_path, "us-interest-rate.csv")
# euir_file <- paste0(folder_path, "eu-interest-rate.csv")
# uscpi_file <- paste0(folder_path, "us-consumer-price-index.csv")
# eucpi_file <- paste0(folder_path, "eu-consumer-price-index.csv")
# 
shares<- read.csv(shares_file)
usm2 <- read.csv(m2_file)
eum2 <- read.csv(m2_file2)
# usir <- read.csv(usir_file)
# euir <- read.csv(euir_file)
# uscpi <- read.csv(uscpi_file)
# eucpi <- read.csv(eucpi_file)
comp_file <- paste0(folder_path, "cleaned_data_without_scale.csv")
all_data <- read.csv(comp_file)

```

```{r}
all_data
```

```{r}

shares

```

```{r}
all_df <- data.frame(all_data)
shares_df <- data.frame(shares)

# all_df$DATE <- as.Date(all_df$DATE)
# shares_df$DATE <- as.Date(shares_df$DATE)

alldata_df <- merge(all_df, shares, by = "DATE")
colnames(alldata_df)[8] <- "USSP"

alldata_df
```

# Looking at the US Shares File
```{r}

shares_df <- alldata_df[, c(1, 8)]

shares_df$DATE <- as.Date(shares_df$DATE)

gg <- ggplot(shares_df, aes(x = DATE, y = USSP))+
  geom_line(aes(group = 1), color = "blue", size = 1, linetype = "solid") +
  # geom_point() +
  theme_minimal() +
  labs(
    x = "Time",
    y = "Index 2015 = 100"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  geom_vline(xintercept = as.numeric(as.Date('2020-03-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2022-02-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2009-06-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2007-12-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  theme(
      panel.background = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
    )

shares_gg <- ggplotly(gg)

shares_gg

ggsave("us-shares.png", plot = gg, device = "png", width = 7, height = 4)

```

```{r}

stl_result <- stl(ts(shares_df$USSP, frequency = 12), s.window = 44)

plot(stl_result)

```

```{r}

tsdisplay(shares_df$USSP, lag = 200)
tsdisplay(diff(shares_df$USSP), lag = 200)

```

```{r}

acf_result <- acf(diff(shares_df$USSP), lag.max = 200, plot = FALSE)

acf_df <- data.frame(lag = acf_result$lag, acf_value = abs(acf_result$acf))

sorted_acf_df <- acf_df[order(-acf_df$acf_value), ]

sorted_acf_df[2:5, c(1, 2)]


```

```{r}

pacf_result <- pacf(diff(shares_df$USSP), lag.max = 200, plot = FALSE)

pacf_df <- data.frame(lag = pacf_result$lag, pacf_value = abs(pacf_result$acf))

sorted_pacf_df <- pacf_df[order(-pacf_df$pacf_value), ]

sorted_pacf_df[1:4, c(1, 2)]

```

```{r}

pacf_result <- pacf(shares_df$USSP, lag.max = 200, plot = FALSE)

pacf_df <- data.frame(lag = pacf_result$lag, pacf_value = abs(pacf_result$acf))

sorted_pacf_df <- pacf_df[order(-pacf_df$pacf_value), ]

sorted_pacf_df[1:3, c(1, 2)]

```

```{r}

sh_rows <- nrow(shares_df)

shares_dftest <- shares_df[(sh_rows - 5):sh_rows, ]
shares_dftrain <- shares_df[1:(sh_rows - 6), ]

shares_dftrain$USSP <- scale(
  shares_dftrain$USSP,
  center = TRUE,
  scale = TRUE
)

sh_mean <- attr(shares_dftrain$USSP, "scaled:center")
sh_sd <- attr(shares_dftrain$USSP, "scaled:scale")

shares_dftest$USSP <- scale(
  shares_dftest$USSP,
  center = attr(shares_dftrain$USSP, "scaled:center"),
  scale = attr(shares_dftrain$USSP, "scaled:scale")
)

```

```{r}

auto.arima(shares_df$USSP)

```

```{r}

# arima_model <- arima(shares_dftrain$USSP, order = c(0, 1, 1))
# # print(test_data)
# predictions <- predict(arima_model, 6)
# predicted_values <- predictions$pred
# # print("-----------------------------")
# print(predicted_values)
# 
# rmse = sqrt(mean((shares_dftest$USSP - predicted_values)^2))
# print(rmse)

```

## ARIMA for Predicting US Share Prices
```{r}

# Function to train and test ARIMA models
train_test_arima <- function(p, d, q, train_data, test_data) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q))
  # print(test_data)
  # Test the model
  predictions <- predict(arima_model, 6)
  predicted_values <- as.numeric(predictions$pred)
  # print("-----------------------------")
  # print(predicted_values)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate RMSE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse*sh_sd)+sh_mean,
    test_MAE = (test_mae*sh_sd)+sh_mean,
    model_AIC = model_aic
    # predicted_value1 = predicted_values[1],
    # predicted_value2 = predicted_values[2],
    # predicted_value3 = predicted_values[3],
    # predicted_value4 = predicted_values[4],
    # predicted_value5 = predicted_values[5],
    # predicted_value6 = predicted_values[6]
  ))
}

# Initialize an empty data frame to store results
results_df <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arima(p, d, q, shares_dftrain$USSP, shares_dftest$USSP)
      
      # Append results to the data frame
      results_df <- rbind(results_df, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- results_df[order(results_df$test_RMSE), ]

ordered_results_df

```

```{r}
ggAcf(residuals(arima(shares_dftrain$USSP, order = c(0, 2, 1))), lag.max = 300)

ggAcf(residuals(arima(shares_dftrain$USSP, order = c(2, 2, 2))), lag.max = 300)

ggAcf(residuals(arima(shares_dftrain$USSP, order = c(2, 2, 1))), lag.max = 300)

ggAcf(residuals(arima(shares_dftrain$USSP, order = c(0, 2, 2))), lag.max = 300)

ggAcf(residuals(arima(shares_dftrain$USSP, order = c(0, 1, 1))), lag.max = 300)

ggAcf(residuals(arima(shares_dftrain$USSP, order = c(1, 1, 0))), lag.max = 300)

ggAcf(residuals(arima(shares_dftrain$USSP, order = c(0, 1, 2))), lag.max = 300)

ggAcf(residuals(arima(shares_dftrain$USSP, order = c(0, 2, 0))), lag.max = 300)
```

# Looking at the US Interest Rate and the US M2
## USD Interest Rate
```{r}

usir_df <- alldata_df[, c(1, 7)]

usir_df$DATE <- as.Date(usir_df$DATE)

gg <- ggplot(usir_df, aes(x = DATE, y = IRUS))+
  geom_line(aes(group = 1), color = "blue", linewidth = 0.5) +
  # geom_point() +
  labs(
    title = "US Interest Rate",
    x = "Time",
    y = "Percentage of change"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

usir_gg <- ggplotly(gg)

usir_gg

```

```{r}
tsdisplay(usir_df$IRUS, lag = 200)
tsdisplay(diff(usir_df$IRUS), lag = 200)
tsdisplay(diff(usir_df$IRUS, 2), lag = 200)
```

## USD M2
```{r}
usm2
```

```{r}

usm2$DATE <- as.Date(usm2$DATE)

usm2$DATE <- format(usm2$DATE, "%Y-%m-01")

aggusm2_df <- usm2 %>%
  group_by(DATE) %>%
  summarise(USM2 = mean(WM2NS, na.rm = TRUE))

# aggusm2_df
aggusm2_df$DATE <- as.Date(aggusm2_df$DATE)
usir_df$DATE <- as.Date(usir_df$DATE)

usm2ir_df <- merge(aggusm2_df, usir_df, by = "DATE")

usm2ir_df

```

```{r}

gg <- ggplot(usm2ir_df, aes(x = DATE, y = USM2))+
  geom_line(aes(group = 1), color = "green", linewidth = 0.5) +
  # geom_point() +
  labs(
    title = "US M2",
    x = "Time",
    y = "Million (USD)"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

usm2_gg <- ggplotly(gg)

usm2_gg

```

```{r}
tsdisplay(usm2ir_df$USM2, lag = 100)
tsdisplay(diff(usm2ir_df$USM2), lag = 100)
tsdisplay(diff(diff(usm2ir_df$USM2), 12), lag = 100)
tsdisplay(diff(usm2ir_df$USM2, 2), lag = 100)
```
```{r}

ggAcfConditional(diff(usm2ir_df$USM2), lag=40, filename = "eu-m2-seasonality")
ggAcfConditional(diff(eum2ir_df$EUM2), lag=40, filename = "us-m2-seasonality")

```

### ACF and PACF for the First US M2 Differenciation
#### This shows a seasonality of 12 months
```{r}

acf_result <- acf(diff(usm2ir_df$USM2), lag.max = 200, plot = FALSE)

acf_df <- data.frame(lag = acf_result$lag, acf_value = acf_result$acf)

sorted_acf_df <- acf_df[order(-acf_df$acf_value), ]

sorted_acf_df[sorted_acf_df$acf_value>0.11, c(1, 2)]

```

```{r}

pacf_result <- pacf(diff(usm2ir_df$USM2), lag.max = 200, plot = FALSE)

pacf_df <- data.frame(lag = pacf_result$lag, pacf_value = pacf_result$acf)

sorted_pacf_df <- pacf_df[order(-pacf_df$pacf_value), ]

sorted_pacf_df[sorted_pacf_df$pacf_value>0.11, c(1, 2)]

```

### ACF and PACF for the Seasonal and First US M2 Differenciations
```{r}

acf_result <- acf(diff(diff(usm2ir_df$USM2), 12), lag.max = 200, plot = FALSE)

acf_df <- data.frame(lag = acf_result$lag, acf_value = acf_result$acf)

sorted_acf_df <- acf_df[order(-acf_df$acf_value), ]

sorted_acf_df[abs(sorted_acf_df$acf_value)>0.11, c(1, 2)]

```

```{r}

pacf_result <- pacf(diff(diff(usm2ir_df$USM2), 12), lag.max = 200, plot = FALSE)

pacf_df <- data.frame(lag = pacf_result$lag, pacf_value = pacf_result$acf)

sorted_pacf_df <- pacf_df[order(-pacf_df$pacf_value), ]

sorted_pacf_df[abs(sorted_pacf_df$pacf_value)>0.11, c(1, 2)]

```

```{r}

usm2_stl <- stl(ts(diff(usm2ir_df$USM2), frequency = 12), s.window = 12)

plot(usm2_stl)

```

## Looking at US IR & M2
### Investigating at US IR and DIFF(M2)
```{r}

usm2diffir_df <- alldata_df[, c(1, 4, 7)]

usm2diffir_df

```

```{r}
tsdisplay(usm2diffir_df$IRUS, lag.max=200)
tsdisplay(diff(usm2diffir_df$IRUS), lag.max=200)
tsdisplay(diff(usm2diffir_df$IRUS, 2), lag.max=200)
```

```{r}

total_rows <- nrow(usm2diffir_df)

usm2diffir_dftest <- usm2diffir_df[(total_rows - 5):total_rows, ]
usm2diffir_dftrain <- usm2diffir_df[1:(total_rows - 6), ]

usm2diffir_dftrain$M2US <- scale(
  usm2diffir_dftrain$M2US,
  center = TRUE,
  scale = TRUE
)

usm2diffir_dftrain$IRUS <- scale(
  usm2diffir_dftrain$IRUS,
  center = TRUE,
  scale = TRUE
)

usm2diff_mean <- attr(usm2diffir_dftrain$M2US, "scaled:center")
usm2diff_sd <- attr(usm2diffir_dftrain$M2US, "scaled:scale")

usir_mean <- attr(usm2diffir_dftrain$IRUS, "scaled:center")
usir_sd <- attr(usm2diffir_dftrain$IRUS, "scaled:scale")

usm2diffir_dftest$M2US <- scale(
  usm2diffir_dftest$M2US,
  center = usm2diff_mean,
  scale = usm2diff_sd
)

usm2diffir_dftest$IRUS <- scale(
  usm2diffir_dftest$IRUS,
  center = usir_mean,
  scale = usir_sd
)

```

```{r}
usm2diffir_dftrain
```

```{r}

usm2diffir_dftrain$DATE <- as.Date(usm2diffir_dftrain$DATE)

gg <- ggplot(usm2diffir_dftrain, aes(x = DATE))+
  geom_line(aes(y = IRUS), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = M2US), color = "green", size = 1, linetype = "solid") +
  # geom_point() +
  labs(
    title = "US M2 Change and IRUS Over Time",
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

usm2diffir_gg <- ggplotly(gg)

usm2diffir_gg

```

### Checking for Linear Correlation
```{r}

linear_corr <- cor(usm2diffir_dftrain$M2US, usm2diffir_dftrain$IRUS, method = "pearson")

corr_test <- rcorr(as.matrix(usm2diffir_dftrain[c("M2US", "IRUS")]), type = "pearson")

p_value <- corr_test$P[1, 2]

cat("Linear Correlation:", linear_corr, "\n")
cat("Significance (p-value):", p_value, "\n")
```

### Checking for Nonlinear Correlation
```{r}

nonlinear_corr <- cor(usm2diffir_dftrain$M2US, usm2diffir_dftrain$IRUS, method = "spearman")

nonlinear_corr_test <- rcorr(as.matrix(usm2diffir_dftrain[c("M2US", "IRUS")]), type = "spearman")

nonlinear_p_value <- nonlinear_corr_test$P[1, 2]

cat("Non-linear (Spearman) Correlation:", nonlinear_corr, "\n")
cat("Significance (p-value):", nonlinear_p_value, "\n")
```

```{r}
auto.arima(usm2diffir_dftrain$IRUS)
auto.arima(usm2diffir_dftrain$M2US)
```

### ARIMA for Predicting US Interest Rate
```{r}

# Function to train and test ARIMA models
train_test_arima <- function(p, d, q, train_data, test_data) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q))
  # print(test_data)
  # Test the model
  predictions <- predict(arima_model, 6)
  predicted_values <- as.numeric(predictions$pred)
  # print("-----------------------------")
  # print(predicted_values)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate RMSE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse*usir_sd)+usir_mean,
    test_MAE = (test_mae*usir_sd)+usir_mean,
    model_AIC = model_aic
    # predicted_value1 = predicted_values[1],
    # predicted_value2 = predicted_values[2],
    # predicted_value3 = predicted_values[3],
    # predicted_value4 = predicted_values[4],
    # predicted_value5 = predicted_values[5],
    # predicted_value6 = predicted_values[6]
  ))
}

# Initialize an empty data frame to store results
arimausirm2diff_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arima(p, d, q, usm2diffir_dftrain$IRUS, usm2diffir_dftest$IRUS)
      
      # Append results to the data frame
      arimausirm2diff_results <- rbind(arimausirm2diff_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimausirm2diff_results[order(arimausirm2diff_results$test_RMSE), ]

ordered_results_df

```

```{r}
ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(0, 2, 0))), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(1, 2, 0))), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(2, 2, 0))), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(2, 0, 2))), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(1, 1, 2))), lag.max = 300)
```

### ARIMAX for Predicting US Interest Rate Using M2 Differenciation
```{r}
# Function to train and test ARIMA models
train_test_arimax <- function(p, d, q, train_data, test_data, xreg_train, xreg_test) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), xreg = xreg_train, method = "ML")
  
  # Test the model
  predictions <- predict(arima_model, n.ahead = 6, newxreg = as.matrix(xreg_test))
  predicted_values <- as.numeric(predictions$pred)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate MAE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse * usir_sd) + usir_mean,
    test_MAE = (test_mae * usir_sd) + usir_mean,
    model_AIC = model_aic
  ))
}

# Initialize an empty data frame to store results
arimaxusirm2diff_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arimax(p, d, q, usm2diffir_dftrain$IRUS, usm2diffir_dftest$IRUS, usm2diffir_dftrain[, "M2US", drop = FALSE], usm2diffir_dftest[, "M2US", drop = FALSE])
      
      # Append results to the data frame
      arimaxusirm2diff_results <- rbind(arimaxusirm2diff_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaxusirm2diff_results[order(arimaxusirm2diff_results$test_RMSE), ]

ordered_results_df

```

```{r}
ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(0, 2, 0), xreg = usm2diffir_dftrain[, "M2US", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(1, 2, 0), xreg = usm2diffir_dftrain[, "M2US", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(2, 2, 0), xreg = usm2diffir_dftrain[, "M2US", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(2, 0, 2), xreg = usm2diffir_dftrain[, "M2US", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(usm2diffir_dftrain$IRUS, order = c(1, 1, 2), xreg = usm2diffir_dftrain[, "M2US", drop = FALSE])), lag.max = 300)
```

### Investigating US IR and M2
```{r}
usm2ir_df
```

```{r}

total_rows <- nrow(usm2ir_df)

usm2ir_dftest <- usm2ir_df[(total_rows - 5):total_rows, ]
usm2ir_dftrain <- usm2ir_df[1:(total_rows - 6), ]

usm2ir_dftrain$USM2 <- scale(
  usm2ir_dftrain$USM2,
  center = TRUE,
  scale = TRUE
)

usm2ir_dftrain$IRUS <- scale(
  usm2ir_dftrain$IRUS,
  center = TRUE,
  scale = TRUE
)

usm2_mean <- attr(usm2ir_dftrain$USM2, "scaled:center")
usm2_sd <- attr(usm2ir_dftrain$USM2, "scaled:scale")

usir_mean <- attr(usm2ir_dftrain$IRUS, "scaled:center")
usir_sd <- attr(usm2ir_dftrain$IRUS, "scaled:scale")

usm2ir_dftest$USM2 <- scale(
  usm2ir_dftest$USM2,
  center = usm2_mean,
  scale = usm2_sd
)

usm2ir_dftest$IRUS <- scale(
  usm2ir_dftest$IRUS,
  center = usir_mean,
  scale = usir_sd
)

```

```{r}

usm2ir_dftrain$DATE <- as.Date(usm2ir_dftrain$DATE)

gg <- ggplot(usm2ir_dftrain, aes(x = DATE))+
  geom_line(aes(y = IRUS), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = USM2), color = "red", size = 1, linetype = "solid") +
  theme_minimal() +
  # geom_point() +
  labs(
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  geom_vline(xintercept = as.numeric(as.Date('2020-03-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2022-02-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2009-06-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2007-12-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2001-09-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  theme(
      panel.background = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
    )

usm2ir_gg <- ggplotly(gg)

usm2ir_gg

ggsave("us-m2-ir.png", plot = gg, device = "png", width = 7, height = 4)

```

### Checking for Linear Correlation
```{r}

linear_corr <- cor(usm2ir_dftrain$USM2, usm2ir_dftrain$IRUS, method = "pearson")

corr_test <- rcorr(as.matrix(usm2ir_dftrain[c("USM2", "IRUS")]), type = "pearson")

p_value <- corr_test$P[1, 2]

cat("Linear Correlation:", linear_corr, "\n")
cat("Significance (p-value):", p_value, "\n")
```

### Checking for Nonlinear Correlation
```{r}

nonlinear_corr <- cor(usm2ir_dftrain$USM2, usm2ir_dftrain$IRUS, method = "spearman")

nonlinear_corr_test <- rcorr(as.matrix(usm2ir_dftrain[c("USM2", "IRUS")]), type = "spearman")

nonlinear_p_value <- nonlinear_corr_test$P[1, 2]

cat("Non-linear (Spearman) Correlation:", nonlinear_corr, "\n")
cat("Significance (p-value):", nonlinear_p_value, "\n")
```

```{r}
auto.arima(usm2ir_dftrain$IRUS)
auto.arima(usm2ir_dftrain$USM2)
```

```{r}
usm2ir_dftest[, "USM2", drop = FALSE]
```

### ARIMAX for Predicting US Interest Rate Using M2
```{r}

# Initialize an empty data frame to store results
arimaxusirm2_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arimax(p, d, q, usm2ir_dftrain$IRUS, usm2ir_dftest$IRUS, usm2ir_dftrain[, "USM2", drop = FALSE], usm2ir_dftest[, "USM2", drop = FALSE])

      # Append results to the data frame
      arimaxusirm2_results <- rbind(arimaxusirm2_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaxusirm2_results[order(arimaxusirm2_results$test_RMSE), ]

ordered_results_df

```

### Investigating US IR and Seasonally differenciated M2
```{r}
usm2diffir_df
```

```{r}
usm2diffir_seasonal_df <- usm2diffir_df[, c(1, 2, 3)]

seasonal_diff <- c(rep(NA, 12), diff(usm2diffir_df$M2US, lag = 12, differences = 1))

usm2diffir_seasonal_df$seasonal_diff_M2US <- seasonal_diff[1:length(usm2diffir_df$M2US)]

usm2diffir_seasonal_df <- na.omit(usm2diffir_seasonal_df)

usm2diffir_seasonal_df <- usm2diffir_seasonal_df[, c(1, 3, 4)]

colnames(usm2diffir_seasonal_df)[3] <- "M2US"

usm2diffir_seasonal_df
```

```{r}

total_rows <- nrow(usm2diffir_seasonal_df)

usm2diffir_seasonal_dftest <- usm2diffir_seasonal_df[(total_rows - 5):total_rows, ]
usm2diffir_seasonal_dftrain <- usm2diffir_seasonal_df[1:(total_rows - 6), ]

usm2diffir_seasonal_dftrain$M2US <- scale(
  usm2diffir_seasonal_dftrain$M2US,
  center = TRUE,
  scale = TRUE
)

usm2diffir_seasonal_dftrain$IRUS <- scale(
  usm2diffir_seasonal_dftrain$IRUS,
  center = TRUE,
  scale = TRUE
)

usm2diff_seasonal_mean <- attr(usm2diffir_seasonal_dftrain$M2US, "scaled:center")
usm2diff_seasonal_sd <- attr(usm2diffir_seasonal_dftrain$M2US, "scaled:scale")

usir_mean <- attr(usm2diffir_seasonal_dftrain$IRUS, "scaled:center")
usir_sd <- attr(usm2diffir_seasonal_dftrain$IRUS, "scaled:scale")

usm2diffir_seasonal_dftest$M2US <- scale(
  usm2diffir_seasonal_dftest$M2US,
  center = usm2diff_seasonal_mean,
  scale = usm2diff_seasonal_sd
)

usm2diffir_seasonal_dftest$IRUS <- scale(
  usm2diffir_seasonal_dftest$IRUS,
  center = usir_mean,
  scale = usir_sd
)

```

```{r}
usm2diffir_seasonal_dftest
```

```{r}

usm2diffir_seasonal_dftrain$DATE <- as.Date(usm2diffir_seasonal_dftrain$DATE)

gg <- ggplot(usm2diffir_seasonal_dftrain, aes(x = DATE))+
  geom_line(aes(y = IRUS), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = M2US), color = "green", size = 1, linetype = "solid") +
  # geom_point() +
  labs(
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

usm2diffir_seasonal_gg <- ggplotly(gg)

usm2diffir_seasonal_gg

```

### Checking for Linear Correlation
```{r}

linear_corr <- cor(usm2diffir_seasonal_dftrain$M2US, usm2diffir_seasonal_dftrain$IRUS, method = "pearson")

corr_test <- rcorr(as.matrix(usm2diffir_seasonal_dftrain[c("M2US", "IRUS")]), type = "pearson")

p_value <- corr_test$P[1, 2]

cat("Linear Correlation:", linear_corr, "\n")
cat("Significance (p-value):", p_value, "\n")
```

### Checking for Nonlinear Correlation
```{r}

nonlinear_corr <- cor(usm2diffir_seasonal_dftrain$M2US, usm2diffir_seasonal_dftrain$IRUS, method = "spearman")

nonlinear_corr_test <- rcorr(as.matrix(usm2diffir_seasonal_dftrain[c("M2US", "IRUS")]), type = "spearman")

nonlinear_p_value <- nonlinear_corr_test$P[1, 2]

cat("Non-linear (Spearman) Correlation:", nonlinear_corr, "\n")
cat("Significance (p-value):", nonlinear_p_value, "\n")
```

```{r}
auto.arima(usm2diffir_seasonal_dftrain$IRUS)
auto.arima(usm2diffir_seasonal_dftrain$M2US)
```

### ARIMAX for Predicting US Interest Rate Using Seasonally Differenciated M2
```{r}

# Function to train and test ARIMA models
train_test_arimax <- function(p, d, q, train_data, test_data, xreg_train, xreg_test) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), xreg = xreg_train, method = "ML")
  
  # Test the model
  predictions <- predict(arima_model, n.ahead = 6, newxreg = as.matrix(xreg_test))
  predicted_values <- as.numeric(predictions$pred)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate MAE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse * usir_sd) + usir_mean,
    test_MAE = (test_mae * usir_sd) + usir_mean,
    model_AIC = model_aic
  ))
}

# Initialize an empty data frame to store results
arimaxusirm2diff_seasonal_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arimax(p, d, q, usm2diffir_seasonal_dftrain$IRUS, usm2diffir_seasonal_dftest$IRUS, usm2diffir_seasonal_dftrain[, "M2US", drop = FALSE], usm2diffir_seasonal_dftest[, "M2US", drop = FALSE])
      
      # Append results to the data frame
      arimaxusirm2diff_seasonal_results <- rbind(arimaxusirm2diff_seasonal_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaxusirm2diff_seasonal_results[order(arimaxusirm2diff_seasonal_results$test_RMSE), ]

ordered_results_df

```

## Comparison of RMSE Results
```{r}
# Combine the results into one data frame
usir_combined_results <- rbind(
  cbind(arimausirm2diff_results, model_group = "ARIMA"),
  # cbind(arimaxusirm2diff_results, model_group = "ARIMAX_diff"),
  # cbind(arimaxusirm2_results, model_group = "ARIMAX"),
  cbind(arimaxusirm2diff_seasonal_results, model_group = "ARIMAX_diff_season")
)

# Convert the test_RMSE column to numeric (in case it's not already)
usir_combined_results$test_RMSE <- as.numeric(usir_combined_results$test_RMSE)

gg <- ggplot(usir_combined_results, aes(x = model_type, y = test_RMSE, fill = model_group)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparison of Test RMSE for Predicting US IR",
       x = "Model Type",
       y = "Test RMSE") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

rmse_compr <- ggplotly(gg)

rmse_compr
```

```{r}
usir_combined_results
```

## Comparison of Model AICs
```{r}
# Calculate the minimum AIC value
min_AIC_value <- min(usir_combined_results$model_AIC)
min_AIC_index <- which.min(usir_combined_results$model_AIC)
min_AIC_model_type <- usir_combined_results$model_type[min_AIC_index]

# Create a data frame for the point
point_data <- data.frame(
  model_type = min_AIC_model_type,
  model_AIC = min_AIC_value,
  model_group = unique(usir_combined_results$model_group)[1]  # Use the first model_group for consistency
)

# Create the ggplot
gg <- ggplot(usir_combined_results, aes(x = model_type, y = model_AIC, color = model_group, group = model_group)) +
  geom_line() +
  labs(
    title = "Comparison of AIC Values for Predicting US IR",
    x = "Model Type",
    y = "Model AIC"
  ) +
  theme_minimal() +
  geom_hline(yintercept = as.numeric(min(combined_results$model_AIC)), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_point(
    data = point_data,
    aes(x = model_type, y = model_AIC, color = model_group),
    color = "black",
    stroke = 0.5
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Convert ggplot to plotly
aic_compr <- ggplotly(gg)

# Display the plotly object
aic_compr
```

# Looking at the EU Interest Rate and the EU M2
## EU Interest Rate
```{r}

euir_df <- alldata_df[, c(1, 6)]

euir_df$DATE <- as.Date(euir_df$DATE)

gg <- ggplot(euir_df, aes(x = DATE, y = IREU))+
  geom_line(aes(group = 1), color = "blue", linewidth = 0.5) +
  # geom_point() +
  labs(
    title = "EU Interest Rate",
    x = "Time",
    y = "Percentage of Change"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

euir_gg <- ggplotly(gg)

euir_gg

```

```{r}
tsdisplay(euir_df$IREU, lag = 200)
tsdisplay(diff(euir_df$IREU), lag = 200)
tsdisplay(diff(euir_df$IREU, 2), lag = 200)
```
## EU M2
```{r}
colnames(eum2)[colnames(eum2) == "M2"] <- "EUM2"

eum2
```

```{r}

eum2$DATE <- as.Date(eum2$DATE)

euir_df$DATE <- as.Date(euir_df$DATE)

eum2ir_df <- merge(eum2, euir_df, by = "DATE")

eum2ir_df

```

```{r}

gg <- ggplot(eum2ir_df, aes(x = DATE, y = EUM2))+
  geom_line(aes(group = 1), color = "blue", linewidth = 0.5) +
  # geom_point() +
  labs(
    title = "EU M2",
    x = "Time",
    y = "Million (EUR)"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

eum2_gg <- ggplotly(gg)

eum2_gg

```

```{r}

tsdisplay(eum2ir_df$EUM2, lag = 100)
tsdisplay(diff(eum2ir_df$EUM2), lag = 100)
tsdisplay(diff(diff(eum2ir_df$EUM2, 12)), lag = 100)
tsdisplay(diff(eum2ir_df$EUM2, 2), lag = 100)

```

### ACF and PACF for the First EU M2 Differenciation
#### The Positive Significant Lags
#### This also shows a seasonality of 12 months
```{r}

acf_result <- acf(diff(eum2ir_df$EUM2), lag.max = 200, plot = FALSE)

acf_df <- data.frame(lag = acf_result$lag, acf_value = acf_result$acf)

sorted_acf_df <- acf_df[order(-acf_df$acf_value), ]

sorted_acf_df[sorted_acf_df$acf_value>0.11, c(1, 2)]

```

```{r}

pacf_result <- pacf(diff(eum2ir_df$EUM2), lag.max = 200, plot = FALSE)

pacf_df <- data.frame(lag = pacf_result$lag, pacf_value = pacf_result$acf)

sorted_pacf_df <- pacf_df[order(-pacf_df$pacf_value), ]

sorted_pacf_df[sorted_pacf_df$pacf_value>0.11, c(1, 2)]

```

#### The Negative Significant Lags
```{r}

acf_result <- acf(diff(eum2ir_df$EUM2), lag.max = 200, plot = FALSE)

acf_df <- data.frame(lag = acf_result$lag, acf_value = acf_result$acf)

sorted_acf_df <- acf_df[order(-acf_df$acf_value), ]

sorted_acf_df[sorted_acf_df$acf_value < -0.11, c(1, 2)]

```

```{r}

pacf_result <- pacf(diff(eum2ir_df$EUM2), lag.max = 200, plot = FALSE)

pacf_df <- data.frame(lag = pacf_result$lag, pacf_value = pacf_result$acf)

sorted_pacf_df <- pacf_df[order(-pacf_df$pacf_value), ]

sorted_pacf_df[sorted_pacf_df$pacf_value < -0.11, c(1, 2)]

```

### ACF and PACF for the Seasonal and First EU M2 Differenciations
```{r}

acf_result <- acf(diff(diff(eum2ir_df$EUM2), 12), lag.max = 200, plot = FALSE)

acf_df <- data.frame(lag = acf_result$lag, acf_value = acf_result$acf)

sorted_acf_df <- acf_df[order(-acf_df$acf_value), ]

sorted_acf_df[abs(sorted_acf_df$acf_value)>0.11, c(1, 2)]

```

```{r}

pacf_result <- pacf(diff(diff(eum2ir_df$EUM2), 12), lag.max = 200, plot = FALSE)

pacf_df <- data.frame(lag = pacf_result$lag, pacf_value = pacf_result$acf)

sorted_pacf_df <- pacf_df[order(-pacf_df$pacf_value), ]

sorted_pacf_df[abs(sorted_pacf_df$pacf_value)>0.11, c(1, 2)]

```

```{r}

eum2_stl <- stl(ts(diff(eum2ir_df$EUM2), frequency = 12), s.window = 12)

plot(eum2_stl)

```

# Looking at EU IR & M2
### Investigating EU IR and DIFF(M2)
```{r}

eum2diffir_df <- alldata_df[, c(1, 5, 6)]

eum2diffir_df

```

```{r}
tsdisplay(eum2diffir_df$IREU, lag.max=200)
tsdisplay(diff(eum2diffir_df$IREU), lag.max=200)
tsdisplay(diff(eum2diffir_df$IREU, 2), lag.max=200)
```

```{r}

total_rows <- nrow(eum2diffir_df)

eum2diffir_dftest <- eum2diffir_df[(total_rows - 5):total_rows, ]
eum2diffir_dftrain <- eum2diffir_df[1:(total_rows - 6), ]

eum2diffir_dftrain$M2EU <- scale(
  eum2diffir_dftrain$M2EU,
  center = TRUE,
  scale = TRUE
)

eum2diffir_dftrain$IREU <- scale(
  eum2diffir_dftrain$IREU,
  center = TRUE,
  scale = TRUE
)

eum2diff_mean <- attr(eum2diffir_dftrain$M2EU, "scaled:center")
eum2diff_sd <- attr(eum2diffir_dftrain$M2EU, "scaled:scale")

euir_mean <- attr(eum2diffir_dftrain$IREU, "scaled:center")
euir_sd <- attr(eum2diffir_dftrain$IREU, "scaled:scale")

eum2diffir_dftest$M2EU <- scale(
  eum2diffir_dftest$M2EU,
  center = eum2diff_mean,
  scale = eum2diff_sd
)

eum2diffir_dftest$IREU <- scale(
  eum2diffir_dftest$IREU,
  center = euir_mean,
  scale = euir_sd
)

```

```{r}

eum2diffir_dftest

```

```{r}

eum2diffir_dftrain$DATE <- as.Date(eum2diffir_dftrain$DATE)

gg <- ggplot(eum2diffir_dftrain, aes(x = DATE))+
  geom_line(aes(y = IREU), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = M2EU), color = "green", size = 1, linetype = "solid") +
  # geom_point() +
  labs(
    title = "EU M2 Change and IREU Over Time",
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

eum2diffir_gg <- ggplotly(gg)

eum2diffir_gg

```

### Checking for Linear Correlation
```{r}

linear_corr <- cor(eum2diffir_dftrain$M2EU, eum2diffir_dftrain$IREU, method = "pearson")

corr_test <- rcorr(as.matrix(eum2diffir_dftrain[c("M2EU", "IREU")]), type = "pearson")

p_value <- corr_test$P[1, 2]

cat("Linear Correlation:", linear_corr, "\n")
cat("Significance (p-value):", p_value, "\n")

```

### Checking for Nonlinear Correlation
```{r}

nonlinear_corr <- cor(eum2diffir_dftrain$M2EU, eum2diffir_dftrain$IREU, method = "spearman")

nonlinear_corr_test <- rcorr(as.matrix(eum2diffir_dftrain[c("M2EU", "IREU")]), type = "spearman")

nonlinear_p_value <- nonlinear_corr_test$P[1, 2]

cat("Non-linear (Spearman) Correlation:", nonlinear_corr, "\n")
cat("Significance (p-value):", nonlinear_p_value, "\n")

```

```{r}
auto.arima(eum2diffir_df$M2EU)
auto.arima(eum2diffir_df$IREU)
```

### ARIMA for Predicting EU Interest Rate
```{r}

# Function to train and test ARIMA models
train_test_arima <- function(p, d, q, train_data, test_data) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q))
  # print(test_data)
  # Test the model
  predictions <- predict(arima_model, 6)
  predicted_values <- as.numeric(predictions$pred)
  # print("-----------------------------")
  # print(predicted_values)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate RMSE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse*euir_sd)+euir_mean,
    # test_MAE = (test_mae*euir_sd)+euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
    # predicted_value1 = predicted_values[1],
    # predicted_value2 = predicted_values[2],
    # predicted_value3 = predicted_values[3],
    # predicted_value4 = predicted_values[4],
    # predicted_value5 = predicted_values[5],
    # predicted_value6 = predicted_values[6]
  ))
}

# Initialize an empty data frame to store results
arimaeuirm2diff_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arima(p, d, q, eum2diffir_dftrain$IREU, eum2diffir_dftest$IREU)
      
      # Append results to the data frame
      arimaeuirm2diff_results <- rbind(arimaeuirm2diff_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaeuirm2diff_results[order(arimaeuirm2diff_results$test_RMSE), ]

ordered_results_df

```

```{r}
ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(0, 0, 2))), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(2, 0, 1))), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(2, 0, 2))), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(2, 1, 0))), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(1, 1, 2))), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(1, 1, 1))), lag.max = 300)
```

### ARIMAX for Predicting EU Interest Rate Using M2 Differenciation
```{r}

# Function to train and test ARIMA models
train_test_arimax <- function(p, d, q, train_data, test_data, xreg_train, xreg_test) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), xreg = xreg_train)
  
  # Test the model
  predictions <- predict(arima_model, n.ahead = 6, newxreg = as.matrix(xreg_test))
  predicted_values <- as.numeric(predictions$pred)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate MAE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse * euir_sd) + euir_mean,
    # test_MAE = (test_mae * euir_sd) + euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
  ))
}

# Initialize an empty data frame to store results
arimaxeuirm2diff_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arimax(p, d, q, eum2diffir_dftrain$IREU, eum2diffir_dftest$IREU, eum2diffir_dftrain[, "M2EU", drop = FALSE], eum2diffir_dftest[, "M2EU", drop = FALSE])
      
      # Append results to the data frame
      arimaxeuirm2diff_results <- rbind(arimaxeuirm2diff_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaxeuirm2diff_results[order(arimaxeuirm2diff_results$test_RMSE), ]

ordered_results_df

```

```{r}
ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(0, 0, 2), xreg = eum2diffir_dftrain[, "M2EU", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(0 , 0 , 1), xreg = eum2diffir_dftrain[, "M2EU", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(2 , 0 , 1), xreg = eum2diffir_dftrain[, "M2EU", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(2 , 0 , 2), xreg = eum2diffir_dftrain[, "M2EU", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(2, 1, 0), xreg = eum2diffir_dftrain[, "M2EU", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2diffir_dftrain$IREU, order = c(2, 1, 1), xreg = eum2diffir_dftrain[, "M2EU", drop = FALSE])), lag.max = 300)
```

```{r}
eum2ir_df
```

```{r}

total_rows <- nrow(eum2ir_df)

eum2ir_dftest <- eum2ir_df[(total_rows - 5):total_rows, ]
eum2ir_dftrain <- eum2ir_df[1:(total_rows - 6), ]

eum2ir_dftrain$EUM2 <- scale(
  eum2ir_dftrain$EUM2,
  center = TRUE,
  scale = TRUE
)

eum2ir_dftrain$IREU <- scale(
  eum2ir_dftrain$IREU,
  center = TRUE,
  scale = TRUE
)

eum2_mean <- attr(eum2ir_dftrain$EUM2, "scaled:center")
eum2_sd <- attr(eum2ir_dftrain$EUM2, "scaled:scale")

euir_mean <- attr(eum2ir_dftrain$IREU, "scaled:center")
euir_sd <- attr(eum2ir_dftrain$IREU, "scaled:scale")

eum2ir_dftest$EUM2 <- scale(
  eum2ir_dftest$EUM2,
  center = eum2_mean,
  scale = eum2_sd
)

eum2ir_dftest$IREU <- scale(
  eum2ir_dftest$IREU,
  center = euir_mean,
  scale = euir_sd
)

```

```{r}
eum2ir_dftest$EUM2
```

```{r}

eum2ir_dftrain$DATE <- as.Date(eum2ir_dftrain$DATE)

gg <- ggplot(eum2ir_dftrain, aes(x = DATE))+
  geom_line(aes(y = IREU), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = EUM2), color = "gold", size = 1, linetype = "solid") +
  theme_minimal()+
  # geom_point() +
  labs(
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  geom_vline(xintercept = as.numeric(as.Date('2020-03-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2022-04-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2009-05-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2008-09-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  theme(
      panel.background = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
    )

eum2ir_gg <- ggplotly(gg)

eum2ir_gg

ggsave("eu-m2-ir.png", plot = gg, device = "png", width = 7, height = 4)

```

### Checking for Linear Correlation
```{r}

linear_corr <- cor(eum2ir_dftrain$EUM2, eum2ir_dftrain$IREU, method = "pearson")

corr_test <- rcorr(as.matrix(eum2ir_dftrain[c("EUM2", "IREU")]), type = "pearson")

p_value <- corr_test$P[1, 2]

cat("Linear Correlation:", linear_corr, "\n")
cat("Significance (p-value):", p_value, "\n")

```

### Checking for Nonlinear Correlation
```{r}

nonlinear_corr <- cor(eum2ir_dftrain$EUM2, eum2ir_dftrain$IREU, method = "spearman")

nonlinear_corr_test <- rcorr(as.matrix(eum2ir_dftrain[c("EUM2", "IREU")]), type = "spearman")

nonlinear_p_value <- nonlinear_corr_test$P[1, 2]

cat("Non-linear (Spearman) Correlation:", nonlinear_corr, "\n")
cat("Significance (p-value):", nonlinear_p_value, "\n")

```

### ARIMAX for Predicting EU Interest Rate Using M2 
```{r}

# Function to train and test ARIMA models
train_test_arimax <- function(p, d, q, train_data, test_data, xreg_train, xreg_test) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), xreg = xreg_train)
  
  # Test the model
  predictions <- predict(arima_model, n.ahead = 6, newxreg = as.matrix(xreg_test))
  predicted_values <- as.numeric(predictions$pred)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate MAE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse * euir_sd) + euir_mean,
    # test_MAE = (test_mae * euir_sd) + euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
  ))
}

# Initialize an empty data frame to store results
arimaxeuirm2_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arimax(p, d, q, eum2ir_dftrain$IREU, eum2ir_dftest$IREU, eum2ir_dftrain[, "EUM2", drop = FALSE], eum2ir_dftest[, "EUM2", drop = FALSE])
      
      # Append results to the data frame
      arimaxeuirm2_results <- rbind(arimaxeuirm2_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaxeuirm2_results[order(arimaxeuirm2_results$test_RMSE), ]

ordered_results_df

```

```{r}
ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(2, 0, 2), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(2, 0, 1), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(1, 2, 2), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(2, 1, 2), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(1, 1, 2), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(2, 1, 0), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(1, 1, 1), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(2, 2, 2), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)

ggAcf(residuals(arima(eum2ir_dftrain$IREU, order = c(2, 2, 1), xreg = eum2ir_dftrain[, "EUM2", drop = FALSE])), lag.max = 300)
```

### Investigating US IR and Seasonally differenciated M2
```{r}
eum2diffir_df
```

```{r}
eum2diffir_seasonal_df <- eum2diffir_df[, c(1, 2, 3)]

seasonal_diff <- c(rep(NA, 12), diff(eum2diffir_df$M2EU, lag = 12, differences = 1))

eum2diffir_seasonal_df$seasonal_diff_M2US <- seasonal_diff[1:length(eum2diffir_df$M2EU)]

eum2diffir_seasonal_df <- na.omit(eum2diffir_seasonal_df)

eum2diffir_seasonal_df <- eum2diffir_seasonal_df[, c(1, 3, 4)]

colnames(eum2diffir_seasonal_df)[3] <- "M2EU"

eum2diffir_seasonal_df
```

```{r}

total_rows <- nrow(eum2diffir_seasonal_df)

eum2diffir_seasonal_dftest <- eum2diffir_seasonal_df[(total_rows - 5):total_rows, ]
eum2diffir_seasonal_dftrain <- eum2diffir_seasonal_df[1:(total_rows - 6), ]

eum2diffir_seasonal_dftrain$M2EU <- scale(
  eum2diffir_seasonal_dftrain$M2EU,
  center = TRUE,
  scale = TRUE
)

eum2diffir_seasonal_dftrain$IREU <- scale(
  eum2diffir_seasonal_dftrain$IREU,
  center = TRUE,
  scale = TRUE
)

eum2diff_seasonal_mean <- attr(eum2diffir_seasonal_dftrain$M2EU, "scaled:center")
eum2diff_seasonal_sd <- attr(eum2diffir_seasonal_dftrain$M2EU, "scaled:scale")

euir_mean <- attr(eum2diffir_seasonal_dftrain$IREU, "scaled:center")
euir_sd <- attr(eum2diffir_seasonal_dftrain$IREU, "scaled:scale")

eum2diffir_seasonal_dftest$M2EU <- scale(
  eum2diffir_seasonal_dftest$M2EU,
  center = eum2diff_seasonal_mean,
  scale = eum2diff_seasonal_sd
)

eum2diffir_seasonal_dftest$IREU <- scale(
  eum2diffir_seasonal_dftest$IREU,
  center = euir_mean,
  scale = euir_sd
)

```

```{r}
eum2diffir_seasonal_dftest
```

```{r}

eum2diffir_seasonal_dftrain$DATE <- as.Date(eum2diffir_seasonal_dftrain$DATE)

gg <- ggplot(eum2diffir_seasonal_dftrain, aes(x = DATE))+
  geom_line(aes(y = IREU), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = M2EU), color = "green", size = 1, linetype = "solid") +
  # geom_point() +
  labs(
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

eum2diffir_seasonal_gg <- ggplotly(gg)

eum2diffir_seasonal_gg

```

### Checking for Linear Correlation
```{r}

linear_corr <- cor(eum2diffir_seasonal_dftrain$M2EU, eum2diffir_seasonal_dftrain$IREU, method = "pearson")

corr_test <- rcorr(as.matrix(eum2diffir_seasonal_dftrain[c("M2EU", "IREU")]), type = "pearson")

p_value <- corr_test$P[1, 2]

cat("Linear Correlation:", linear_corr, "\n")
cat("Significance (p-value):", p_value, "\n")
```

### Checking for Nonlinear Correlation
```{r}

nonlinear_corr <- cor(eum2diffir_seasonal_dftrain$M2EU, eum2diffir_seasonal_dftrain$IREU, method = "spearman")

nonlinear_corr_test <- rcorr(as.matrix(eum2diffir_seasonal_dftrain[c("M2EU", "IREU")]), type = "spearman")

nonlinear_p_value <- nonlinear_corr_test$P[1, 2]

cat("Non-linear (Spearman) Correlation:", nonlinear_corr, "\n")
cat("Significance (p-value):", nonlinear_p_value, "\n")
```

```{r}
auto.arima(eum2diffir_seasonal_dftrain$IREU)
auto.arima(eum2diffir_seasonal_dftrain$M2EU)
```

### ARIMAX for Predicting EU Interest Rate Using Seasonally Differenciated M2
```{r}

# Function to train and test ARIMA models
train_test_arimax <- function(p, d, q, train_data, test_data, xreg_train, xreg_test) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), xreg = xreg_train, method = "ML")
  
  # Test the model
  predictions <- predict(arima_model, n.ahead = 6, newxreg = as.matrix(xreg_test))
  predicted_values <- as.numeric(predictions$pred)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate MAE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse * euir_sd) + euir_mean,
    # test_MAE = (test_mae * euir_sd) + euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
  ))
}

# Initialize an empty data frame to store results
arimaxeuirm2diff_seasonal_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0, 1, 2)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arimax(p, d, q, eum2diffir_seasonal_dftrain$IREU, eum2diffir_seasonal_dftest$IREU, eum2diffir_seasonal_dftrain[, "M2EU", drop = FALSE], eum2diffir_seasonal_dftest[, "M2EU", drop = FALSE])
      
      # Append results to the data frame
      arimaxeuirm2diff_seasonal_results <- rbind(arimaxeuirm2diff_seasonal_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaxeuirm2diff_seasonal_results[order(arimaxeuirm2diff_seasonal_results$test_RMSE), ]

ordered_results_df

```

## Comparison of RMSE Results
```{r}
# Combine the results into one data frame
euir_combined_results <- rbind(
  cbind(arimaeuirm2diff_results, model_group = "ARIMA"),
  cbind(arimaxeuirm2diff_results, model_group = "ARIMAX_diff"),
  cbind(arimaxeuirm2_results, model_group = "ARIMAX"),
  cbind(arimaxeuirm2diff_seasonal_results, model_group = "ARIMAX_diff_season")
)

# Convert the test_RMSE column to numeric (in case it's not already)
euir_combined_results$test_RMSE <- as.numeric(euir_combined_results$test_RMSE)

gg <- ggplot(euir_combined_results, aes(x = model_type, y = test_RMSE, fill = model_group)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Comparison of Test RMSE for Predicting EU IR",
       x = "Model Type",
       y = "Test RMSE") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

rmse_compr <- ggplotly(gg)

rmse_compr
```

## Comparison of Model AICs
```{r}

# Calculate the minimum AIC value
min_AIC_value <- min(euir_combined_results$model_AIC)
min_AIC_index <- which.min(euir_combined_results$model_AIC)
min_AIC_model_type <- euir_combined_results$model_type[min_AIC_index]

# Create a data frame for the point
point_data <- data.frame(
  model_type = min_AIC_model_type,
  model_AIC = min_AIC_value,
  model_group = unique(euir_combined_results$model_group)[1]  # Use the first model_group for consistency
)

gg <- ggplot(euir_combined_results, aes(x = model_type, y = model_AIC, color = model_group, group = model_group)) +
  geom_line() +
  labs(
    title = "Comparison of AIC Values for Predicting EU IR",
    x = "Model Type",
    y = "Model AIC"
  ) +
  theme_minimal() +
  geom_hline(yintercept = as.numeric(min(combined_results$model_AIC)), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_point(
    data = point_data,
    aes(x = model_type, y = model_AIC, color = model_group),
    color = "black",
    stroke = 0.5
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Convert ggplot to plotly
aic_compr <- ggplotly(gg)

# Display the plotly object
aic_compr

```

```{r}
eum2ir_dftrain
```


```{r}

gg <- ggplot(eum2ir_dftrain, aes(x = EUM2, y = IREU)) +
  geom_line(color = "red", linewidth = 0.5)+
  geom_point() +
  labs(
    title = "Scatter Plot of EUM2 and IREU",
    x = "EUM2",
    y = "IREU"
  )

eum2ir_gg <- ggplotly(gg)

eum2ir_gg

```

## Predicting EU IR from EU M2 using LOESS
```{r}

train_test_loess <- function(sub, sp, deg, train_data_x, train_data_y, test_data_x, test_data_y) {
  # Create a logical vector for subsetting
  subset_logical <- train_data_x <= sub
  
  # Train LOESS model
  loess_model <- loess(train_data_y[subset_logical] ~ train_data_x[subset_logical], 
                       data = data.frame(x = train_data_x[subset_logical], y = train_data_y[subset_logical]), 
                       span = sp, degree = deg)
  
  # Test the model
  predictions <- predict(loess_model, newdata = data.frame(x = test_data_x))
  predicted_values <- as.numeric(predictions)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data_y) - predicted_values)^2))
  
  # Calculate residuals
  residuals <- residuals(loess_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf_result$acf) > 2/sqrt(length(residuals))) - 1
  
  loess_aic <- summary(loess_model)$AIC
  
  # Return results
  return(data.frame(
    model_type = paste("LOESS(", sub, ",", sp, ",", deg, ")"),
    test_RMSE = (test_rmse * euir_sd) + euir_mean,
    significant_lags = sig_lags
  ))
}

loesseuirm2_results <- data.frame()

# subset, span, degree
for (subset_val in c(0.1, 0.2, 0.25, 0.3, 0.5)){
  for (span_val in c(0.25, 0.5, 0.75)){
    for (degree_val in c(1, 2)){
      
      # Train and test LOESS model
      results <- train_test_loess(subset_val, span_val, degree_val, eum2ir_dftrain$EUM2, eum2ir_dftrain$IREU, eum2ir_dftest$EUM2, eum2ir_dftest$IREU)
      
      # Append results to the data frame
      loesseuirm2_results <- rbind(loesseuirm2_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- loesseuirm2_results[order(loesseuirm2_results$test_RMSE), ]

ordered_results_df

```

## Predicting IREU using GAM
```{r}
gameuir_model = gam(IREU ~ s(DATE) + s(EUM2), data = eum2ir_dftrain)

summary(gameuir_model)

```

```{r}
eum2ir_dftest[c(1, 2)]
```

```{r}

euirgam_predictions <- predict(gameuir_model, newdata = eum2ir_dftest[c(1, 2)])

rmse <- sqrt(mean((eum2ir_dftest$IREU - euirgam_predictions)^2))
rmse <- (rmse * euir_sd) + euir_mean

cat("RMSE:", rmse )

```

# Looking at the EU M2 and the US M2
```{r}

euusm2_df <- merge(eum2ir_df[, c(1, 2)], usm2ir_df[, c(1, 2)], by = "DATE")

euusm2_df

```

### Investigating EU M2 and US M2
```{r}

gg <- ggplot(euusm2_dftrain, aes(x = DATE))+
  geom_line(aes(y = EUM2, color = "EUM2"), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = USM2, color = "USM2"), color = "red", size = 1, linetype = "solid") +
  theme_minimal() +
  # geom_point() +
  labs(
    y = "M2",
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  geom_vline(xintercept = as.numeric(as.Date('2020-03-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2022-04-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  theme(
      panel.background = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
    )

euusm2_gg <- ggplotly(gg)

euusm2_gg

ggsave("m2-comparison.png", plot = gg, device = "png", width = 7, height = 4)

```

```{r}
euusm2diff_seasonal_df <- euusm2_df[, c(1, 2, 3)]

eu_seasonal_diff <- c(rep(NA, 12), diff(diff(euusm2diff_seasonal_df$EUM2), lag = 12, differences = 1))
us_seasonal_diff <- c(rep(NA, 12), diff(diff(euusm2diff_seasonal_df$USM2), lag = 12, differences = 1))

euusm2diff_seasonal_df$seasonal_diff_EUM2 <- eu_seasonal_diff[1:length(euusm2diff_seasonal_df$EUM2)]
euusm2diff_seasonal_df$seasonal_diff_USM2 <- us_seasonal_diff[1:length(euusm2diff_seasonal_df$USM2)]

euusm2diff_seasonal_df <- na.omit(euusm2diff_seasonal_df)

euusm2diff_seasonal_df <- euusm2diff_seasonal_df[, c(1, 4, 5)]

colnames(euusm2diff_seasonal_df)[2] <- "EUM2"
colnames(euusm2diff_seasonal_df)[3] <- "USM2"

euusm2diff_seasonal_df
```

```{r}

total_rows <- nrow(euusm2diff_seasonal_df)

euusm2diff_seasonal_dftest <- euusm2diff_seasonal_df[(total_rows - 5):total_rows, ]
euusm2diff_seasonal_dftrain <- euusm2diff_seasonal_df[1:(total_rows - 6), ]

euusm2diff_seasonal_dftrain$EUM2 <- scale(
  euusm2diff_seasonal_dftrain$EUM2,
  center = TRUE,
  scale = TRUE
)

euusm2diff_seasonal_dftrain$USM2 <- scale(
  euusm2diff_seasonal_dftrain$USM2,
  center = TRUE,
  scale = TRUE
)

eum2_mean <- attr(euusm2diff_seasonal_dftrain$EUM2, "scaled:center")
eum2_sd <- attr(euusm2diff_seasonal_dftrain$EUM2, "scaled:scale")

usm2_mean <- attr(euusm2diff_seasonal_dftrain$USM2, "scaled:center")
usm2_sd <- attr(euusm2diff_seasonal_dftrain$USM2, "scaled:scale")

euusm2diff_seasonal_dftest$EUM2 <- scale(
  euusm2diff_seasonal_dftest$EUM2,
  center = eum2_mean,
  scale = eum2_sd
)

euusm2diff_seasonal_dftest$USM2 <- scale(
  euusm2diff_seasonal_dftest$USM2,
  center = usm2_mean,
  scale = usm2_sd
)
```

```{r}
length(euusm2diff_seasonal_df$EUM2)
```

## Checking for Linear Correlation
```{r}

linear_corr <- cor(euusm2diff_seasonal_dftrain$USM2, euusm2diff_seasonal_dftrain$EUM2, method = "pearson")

corr_test <- rcorr(as.matrix(euusm2diff_seasonal_dftrain[c("USM2", "EUM2")]), type = "pearson")

p_value <- corr_test$P[1, 2]

cat("Linear Correlation:", linear_corr, "\n")
cat("Significance (p-value):", p_value, "\n")
```

## Checking for Nonlinear Correlation
```{r}

nonlinear_corr <- cor(euusm2diff_seasonal_dftrain$USM2, euusm2diff_seasonal_dftrain$EUM2, method = "spearman")

nonlinear_corr_test <- rcorr(as.matrix(euusm2diff_seasonal_dftrain[c("USM2", "EUM2")]), type = "spearman")

nonlinear_p_value <- nonlinear_corr_test$P[1, 2]

cat("Non-linear (Spearman) Correlation:", nonlinear_corr, "\n")
cat("Significance (p-value):", nonlinear_p_value, "\n")
```

```{r}

gg <- ggplot(euusm2diff_seasonal_dftrain, aes(x = DATE))+
  geom_line(aes(y = EUM2, color = "EUM2"), color = "blue", size = 1, linetype = "solid") +
  geom_line(aes(y = USM2, color = "USM2"), color = "red", size = 1, linetype = "solid") +
  theme_minimal() +
  # geom_point() +
  labs(
    y = "M2",
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  geom_vline(xintercept = as.numeric(as.Date('2020-03-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_vline(xintercept = as.numeric(as.Date('2022-04-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  theme(
      panel.background = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
    )

euusm2_gg <- ggplotly(gg)

euusm2_gg

ggsave("m2-comparison.png", plot = gg, device = "png", width = 7, height = 4)

```

```{r}
auto.arima(euusm2diff_seasonal_dftrain$EUM2)
auto.arima(euusm2diff_seasonal_dftrain$USM2)
```

## ARIMA for Predicting EU M2
```{r}

# Function to train and test ARIMA models
train_test_arima <- function(p, d, q, train_data, test_data) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), , method = "ML")
  # print(test_data)
  # Test the model
  predictions <- predict(arima_model, 6)
  predicted_values <- as.numeric(predictions$pred)
  # print("-----------------------------")
  # print(predicted_values)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate RMSE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse*eum2_sd)+eum2_mean,
    # test_MAE = (test_mae*euir_sd)+euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
    # predicted_value1 = predicted_values[1],
    # predicted_value2 = predicted_values[2],
    # predicted_value3 = predicted_values[3],
    # predicted_value4 = predicted_values[4],
    # predicted_value5 = predicted_values[5],
    # predicted_value6 = predicted_values[6]
  ))
}

# Initialize an empty data frame to store results
arimaeum2_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arima(p, d, q, euusm2diff_seasonal_dftrain$EUM2, euusm2diff_seasonal_dftest$EUM2)
      
      # Append results to the data frame
      arimaeum2_results <- rbind(arimaeum2_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaeum2_results[order(arimaeum2_results$test_RMSE), ]

ordered_results_df

```

## ARIMA for Predicting US M2
```{r}

# Function to train and test ARIMA models
train_test_arima <- function(p, d, q, train_data, test_data) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), , method = "ML")
  # print(test_data)
  # Test the model
  predictions <- predict(arima_model, 6)
  predicted_values <- as.numeric(predictions$pred)
  # print("-----------------------------")
  # print(predicted_values)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate RMSE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse*usm2_sd)+usm2_mean,
    # test_MAE = (test_mae*euir_sd)+euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
    # predicted_value1 = predicted_values[1],
    # predicted_value2 = predicted_values[2],
    # predicted_value3 = predicted_values[3],
    # predicted_value4 = predicted_values[4],
    # predicted_value5 = predicted_values[5],
    # predicted_value6 = predicted_values[6]
  ))
}

# Initialize an empty data frame to store results
arimausm2_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arima(p, d, q, euusm2diff_seasonal_dftrain$USM2, euusm2diff_seasonal_dftest$USM2)
      
      # Append results to the data frame
      arimausm2_results <- rbind(arimausm2_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimausm2_results[order(arimausm2_results$test_RMSE), ]

ordered_results_df

```

## ARIMAX for Predicting EU M2 with US M2
```{r}

# Function to train and test ARIMA models
train_test_arima <- function(p, d, q, train_data, test_data, xreg_train, xreg_test) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), , method = "ML")
  # print(test_data)
  # Test the model
  predictions <- predict(arima_model, 6)
  predicted_values <- as.numeric(predictions$pred)
  # print("-----------------------------")
  # print(predicted_values)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate RMSE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    test_RMSE = (test_rmse*eum2_sd)+eum2_mean,
    # test_MAE = (test_mae*euir_sd)+euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
    # predicted_value1 = predicted_values[1],
    # predicted_value2 = predicted_values[2],
    # predicted_value3 = predicted_values[3],
    # predicted_value4 = predicted_values[4],
    # predicted_value5 = predicted_values[5],
    # predicted_value6 = predicted_values[6]
  ))
}

# Initialize an empty data frame to store results
arimaxeum2_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0)) {
    for (q in c(0, 1, 2)) {
      # Train and test ARIMA model
      results <- train_test_arima(p, d, q, euusm2diff_seasonal_dftrain$EUM2, euusm2diff_seasonal_dftest$EUM2, euusm2diff_seasonal_dftrain[, "USM2", drop = FALSE], euusm2diff_seasonal_dftest[, "USM2", drop = FALSE])
      
      # Append results to the data frame
      arimaxeum2_results <- rbind(arimaxeum2_results, results)
    }
  }
}

# Print the results data frame
ordered_results_df <- arimaxeum2_results[order(arimaxeum2_results$test_RMSE), ]

ordered_results_df

```

## SARIMA for Predicting US M2
```{r}

# Function to train and test ARIMA models
train_test_arima <- function(p, d, q, s_p, s_d, s_q, train_data, test_data) {
  # Train ARIMA model
  arima_model <- arima(train_data, order = c(p, d, q), seasonal = list(order = c(s_p, s_d, s_q), period = 12), method = "ML")
  # print(test_data)
  # Test the model
  predictions <- predict(arima_model, 6)
  predicted_values <- as.numeric(predictions$pred)
  # print("-----------------------------")
  # print(predicted_values)
  
  # Calculate RMSE
  test_rmse <- sqrt(mean((as.numeric(test_data) - predicted_values)^2))
  
  # Calculate RMSE
  test_mae <- mean(abs(as.numeric(test_data) - predicted_values))
  
  # Get AIC value
  model_aic <- AIC(arima_model)
  
  # Calculate residuals
  residuals <- residuals(arima_model)

  # Calculate ACF
  acf_result <- acf(residuals, lag.max = 300, plot = FALSE)

  # Count significant lags
  sig_lags <- sum(abs(acf(residuals, lag.max = 300, plot = FALSE)$acf) > 2/sqrt(length(residuals))) - 1
  
  # Return results
  return(data.frame(
    model_type = paste("ARIMA(", p, ",", d, ",", q, ")"),
    seasonal_comps = paste("s(", s_p, ",", s_d, ",", s_q, ")"),
    test_RMSE = (test_rmse*usm2_sd)+usm2_mean,
    # test_MAE = (test_mae*euir_sd)+euir_mean,
    significant_lags = sig_lags,
    model_AIC = model_aic
    # predicted_value1 = predicted_values[1],
    # predicted_value2 = predicted_values[2],
    # predicted_value3 = predicted_values[3],
    # predicted_value4 = predicted_values[4],
    # predicted_value5 = predicted_values[5],
    # predicted_value6 = predicted_values[6]
  ))
}

# Initialize an empty data frame to store results
arimausm2_results <- data.frame()

# Try different combinations of p, d, q (range: 0 to 2 inclusive)
for (p in c(0, 1, 2)) {
  for (d in c(0)) {
    for (q in c(0, 1, 2)) {
      for (s_p in c(0, 1)) {
        for (s_d in c(0)){
          for(s_q in c(0, 1, 2)){
            results <- train_test_arima(p, d, q, s_p, s_d, s_q, euusm2diff_seasonal_dftrain$USM2, euusm2diff_seasonal_dftest$USM2)
            
            arimausm2_results <- rbind(arimausm2_results, results)
          }
        }
      }
    }
  }
}

# Print the results data frame
ordered_results_df <- arimausm2_results[order(arimausm2_results$test_RMSE), ]

ordered_results_df

```

```{r}
total_rows <- nrow(euusm2_df)

euusm2_dftest <- euusm2_df[(total_rows - 5):total_rows, ]
euusm2_dftrain <- euusm2_df[1:(total_rows - 6), ]
```

## Predicting EU M2 using GAM
```{r}

Month <- as.numeric(format(euusm2_dftrain$DATE, "%m"))

gameum2_model = gam(EUM2 ~ s(Month) + s(USM2), data = euusm2_dftrain)

summary(gameum2_model)

```

```{r}
# Train set
# Month_train <- as.numeric(format(euusm2_dftrain$DATE, "%m"))
# 
# gameum2_model <- gam(euusm2_dftrain$EUM2 ~ s(Month_train) + s(euusm2_dftrain$USM2))
# 
# summary(gameum2_model)
# gameum2_model$fitted.values
# # Test set
# Month_test <- as.numeric(format(euusm2_dftest$DATE, "%m"))
# 
# # Create a data frame for prediction
# abc_data <- data.frame(Month = Month_test, USM2 = euusm2_dftest$USM2[1:6])
# print(abc_data)
# eum2gam_predictions <- predict(gameum2_model, abc_data = new_data)
# print(eum2gam_predictions)
# rmse <- sqrt(mean((euusm2_dftest$EUM2[1:6] - eum2gam_predictions)^2))
# print(length(eum2gam_predictions))
# # plot_combined_data(train_data =euusm2_dftrain,
# #                    test_data = euusm2_dftest,
# #                    col = "EUM2",
# #                    forecasted_train = gameum2_model$fitted.values,
# #                    forecasted_test = eum2gam_predictions,
# #                    model = "gam"
# #                    )
# 
# cat("RMSE:", rmse)

# Train set
Month_train <- as.numeric(format(euusm2_dftrain$DATE, "%m"))

gameum2_model <- gam(EUM2 ~ s(Month_train) + s(USM2), data = euusm2_dftrain)

summary(gameum2_model)
fitted_values_train <- gameum2_model$fitted.values  # Save the fitted values for the train set

# Test set
Month_test <- as.numeric(format(euusm2_dftest$DATE, "%m"))

# Create a data frame for prediction
new_data <- data.frame(Month = Month_test, USM2 = as.numeric(euusm2_dftest$USM2))
new_data
eum2gam_predictions <- predict(gameum2_model, newdata = new_data[:6,])

# Print the data and predictions
print(new_data)
print(eum2gam_predictions)

# Calculate RMSE for the first 6 observations
rmse <- sqrt(mean((euusm2_dftest$EUM2[1:6] - eum2gam_predictions)^2))

cat("RMSE:", rmse)

```

```{r}
gg <- ggplot(euir_combined_results, aes(x = model_type, y = model_AIC, color = model_group, group = model_group)) +
  geom_line() +
  labs(
    title = "Comparison of AIC Values for Predicting EU IR",
    x = "Model Type",
    y = "Model AIC"
  ) +
 theme_minimal() +
  geom_hline(yintercept = as.numeric(min(eum2_combined_results$model_AIC)), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  geom_point(
    data = point_data,
    aes(x = model_type, y = model_AIC, color = model_group),
    color = "black",
    stroke = 0.5
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Convert ggplot to plotly
aic_compr <- ggplotly(gg)

# Display the plotly object
aic_compr

```

```{r}
euuscpi_df = data.frame(all_data[, c(1, 2, 3)])

euuscpi_df$DATE <- as.Date(euuscpi_df$DATE)

gg <- ggplot(euuscpi_df, aes(x = DATE))+
  geom_line(aes(y = CPIEU), color = "blue", size = 0.5, linetype = "solid") +
  geom_line(aes(y = CPIUS), color = "gold", size = 0.5, linetype = "solid") +
  theme_minimal()+
  # geom_point() +
  labs(
    y = "CPI",
    x = "Time"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  # geom_vline(xintercept = as.numeric(as.Date('2020-03-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  # geom_vline(xintercept = as.numeric(as.Date('2022-04-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  # geom_vline(xintercept = as.numeric(as.Date('2009-05-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  # geom_vline(xintercept = as.numeric(as.Date('2008-09-01')), linetype = "dashed", color = "black", size = 1, linewidth = 0.5) +
  theme(
      panel.background = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)
    )

euuscpi_gg <- ggplotly(gg)

euuscpi_gg

ggsave("cpi-comp.png", plot = gg, device = "png", width = 7, height = 4)

```


# Plotting Models
```{r}

ggAcfConditional <- function(data, color_above_threshold = "#aa6060", color_below_threshold="#79a3a0", lag=25, filename="test") {
  acf_result <- acf(data, plot = FALSE, lag.max =lag )
  df_acf <- data.frame(lag = acf_result$lag, acf = acf_result$acf)
  
  # Determine the threshold as the 95% confidence interval
  threshold <- qnorm(0.975) / sqrt(length(data))
  
  # Add a new column indicating whether the absolute ACF value exceeds the threshold
  df_acf$color <- ifelse(abs(df_acf$acf) >= threshold, color_above_threshold, color_below_threshold)
  
   plt<-ggplot(df_acf, aes(x = lag, y = acf, fill = color)) +
    geom_bar(stat = "identity", width = 0.2) +
    geom_hline(yintercept = c(-threshold, threshold), linetype = "dashed", color = "blue", size = 0.2) +
    # annotate("text", x = 0, y = 0, label = "White Noise Region", color = "black", hjust = 0) +
    geom_text(data = subset(df_acf, abs(acf) > threshold), aes(label = lag), vjust = -0.5, color = "black", size = 3) +
    labs(x = "Lag",
         y = "Autocorrelation",
         title = "") +
    scale_fill_manual(values = c(color_below_threshold,color_above_threshold)) +
    theme(legend.position = "none",  # Remove legend
          panel.background = element_blank(),  # Remove panel background
          plot.background = element_blank())
   print(plt)
  ggsave(
      paste0(filename, "_acf.png"),
      width = 1780,
      height = 500,
      units = "px"
    )
}

plot_combined_data <- function(train_data, test_data, col, forecasted_train, forecasted_test, model) {

  
  train_data_a <-
    data.frame(cbind(
      actual = as.vector(train_data[[col]]),
      Set = "Training",
      predict = as.vector(forecasted_train)
    ))
  test_data_a <-
    data.frame(cbind(
      actual = as.vector(test_data[[col]]),
      Set = "Test",
      predict = as.vector(forecasted_test)
    ))
  print(forecasted_test)
  print(test_data)
  print(train_data_a)
   print(test_data_a)
  data <- rbind(train_data_a, test_data_a)
  start_date <- min(c(train_data$DATE, test_data$DATE))
  end_date <- max(c(train_data$DATE, test_data$DATE))
  
  data$DATE <- seq(start_date, end_date, by = "1 month")
  data$actual <- as.numeric(data$actual)
  data$predict <- as.numeric(data$predict)


  gg_plot_combined <- ggplot(data, aes(x = DATE, color = Set)) +
    geom_line(aes(y = actual, linetype = "Actual"), size = 0.5, color = "#aa6060") +
    geom_line(aes(y = predict, linetype = "Predictions"), size = 0.5) +
    labs(
      title = "",
      x = "Date",
      y = col,
      color = "Set",
      linetype = "Linetype"
    ) +
    scale_color_manual(values = c("Training" = "#79a3a0", "Test" = "blue")) +
    scale_linetype_manual(values = c("Predictions" = "solid", "Actual" = "dashed")) +
    theme_minimal() +
    theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank())

  # Print the combined plot
  print(gg_plot_combined)

  # Save the combined plot
  ggsave(
    paste0(col, "_",model, "_predict.png"),
    plot = gg_plot_combined,
    width = 1426,
    height = 950,
    units = "px"
  )

  residuals_plot <- ggplot(data, aes(x = DATE, y = predict - actual, color = Set)) +
    geom_line(size = 1) +
    labs(
      title = "",
      x = "Date",
      y = "Residuals",
      color = "Set"
    ) +
    scale_color_manual(values = c("Training" = "#79a3a0", "Test" = "#aa6060")) +
    theme_minimal()

  # Print the residuals plot
  print(residuals_plot)

  # Save the residuals plot
  ggsave(
    paste0(col, "_", model, "_residuals.png"),
    plot = residuals_plot,
    width = 1700,
    height = 500,
    units = "px"
  )

  # Assuming ggAcfConditional is a custom function
  # Make sure it is defined and properly used
  ggAcfConditional(data$predict - data$actual, lag = 25, filename = paste0(col, "_",model))
}

```

# Plotting ARIMAs
```{r}

arima_plot <-
  function(train_data,
           order,
           test_data_x,
           s_order=c(0,0,0),
           y_col = "dollar",
           xreg_train = NULL,
           xreg_test = NULL) {
    # Fit ARIMA model
    f3 <- NULL
    ts_model <- NULL
    if (!is.null(xreg_train)) {
      ts_model <-
        Arima(
          train_data[[y_col]],
          order = order,
          seasonal = s_order,
          include.mean = TRUE,
          xreg = xreg_train
        )

      # Generate forecast

      f3 <- forecast(ts_model, xreg = xreg_test, h=nrow(test_data_x))
    } else {
      ts_model <- Arima(train_data[[y_col]],
        order = order,
        seasonal = s_order,
        include.mean = TRUE
      )
      f3 <- forecast(ts_model, h=nrow(test_data_x))
    }
    # print(time(f3$lower)[1])
    # check_r(ts_model)
    base_plot <- autoplot(f3,
      ts.colour = "yellow", predict.colour = "green",
      predict.linetype = "dashed", conf.int = FALSE, predict.fill = "purple"
    )
    styled_plot <- base_plot +
      geom_point(
        data = test_data_x,
        aes(x = (time(f3$lower)[1]):((time(f3$lower)[1]) + nrow(test_data_x) - 1), y = !!sym(y_col)),
        color = "red",
        size = 1
      ) +
      theme_minimal() +
      labs(title = sprintf("Forecast %s", y_col), x = "Time", y = y_col) +
      # scale_color_manual(values = c("blue", "red")) +
      guides(color = guide_legend(title = "Legend Title"))


    print(styled_plot)



    # Extract actual values from test data
    actual_values <- as.vector(test_data_x[[y_col]])

    # Extract forecasted values
    forecasted_values <- as.vector(f3$mean)


    # Calculate Mean Absolute Error (MAE)
    error_o <- na.omit(actual_values - forecasted_values)
    rmse <- sqrt(mean(na.omit(error_o ^ 2)))
    
    mae_value <- mean(abs(actual_values - forecasted_values))
    # message("RMSE: ", rmse, "\n", "MAE: ", mae_value, "\n")
    print(ts_model$fitted.values)
    return(list(model = ts_model, forecast = forecasted_values, fitted_values = fitted(ts_model)))
  }

# a<-arima_plot(eum2ir_dftrain,
#     order = c(1, 1, 2),
#      # s_order = list(order = c(0, 0, 0), frequency = 12),
#      test_data_x = eum2ir_dftest,
#      y_col = "IREU",
#      xreg_train = as.matrix(eum2ir_dftrain[["EUM2"]]),
#      xreg_test = as.matrix(eum2ir_dftest[["EUM2"]])
# )
# plot_combined_data(train_data = eum2ir_dftrain
#                    ,test_data = eum2ir_dftest
#                    ,col = "IREU"
#                    ,forecasted_train = a$fitted_values
#                    ,forecasted_test = a$forecast
#                    ,model = "arimax")

```

```{r}

# plot_combined_data(train_data = usm2ir_dftrain
#                    ,test_data = usm2ir_dftest
#                    ,col = "IRUS"
#                    ,forecasted_train = eum2ir_dftrain$IREU
#                    ,forecasted_test = eum2ir_dftest$IREU
#                    ,model = "loess")

```

```{r}
# eum2diffir_dftrain
```

```{r}

a<-arima_plot(eum2ir_dftrain,
    order = c(2, 0, 1),
     # s_order = list(order = c(0, 0, 0), frequency = 12),
     test_data_x = eum2ir_dftest,
     y_col = "IREU",
     xreg_train = as.matrix(eum2ir_dftrain[["EUM2"]]),
     xreg_test = as.matrix(eum2ir_dftest[["EUM2"]])
)

arima_plot <- plot_combined_data(train_data = eum2ir_dftrain
                   ,test_data = eum2ir_dftest
                   ,col = "IREU"
                   ,forecasted_train = a$fitted_values
                   ,forecasted_test = a$forecast
                   ,model = "arimax")

arima_plot
# ggsave("best-arima.png", plot = arima_plot, device = "png", width = 7, height = 4)


```



